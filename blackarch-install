#!/bin/bash
################################################################################
#                                                                              #
# blackarchinstall - Blackarch Install                                         #
#                                                                              #
# FILE                                                                         #
# blackarchinstall.sh                                                          #
#                                                                              #
# DATE                                                                         #
# 2013-12-16                                                                   #
#                                                                              #
# DESCRIPTION                                                                  #
# Script for easy install                                                      #
#                                                                              #
# AUTHOR                                                                       #
# nrz@nullsecurity.net                                                         #
#                                                                              #
################################################################################

# SECURITY VAR - this version can rm -rf /* your hard drive
SEC_ENABLE="true"


# root variable
ROOT="/mnt/blackarch"

# BA REPO
BLACKARCH_REPO_URL='http://www.blackarch.org/blackarch/$repo/os/$arch'

# blackarchinstall version
VERSION="v0.2beta"

# true / false
FALSE="0"
TRUE="1"

# return codes
SUCCESS="1337"
FAILURE="31337"

# verbose mode - default: quiet
VERBOSE="/dev/null"

# colors
WHITE="$(tput bold ; tput setaf 7)"
GREEN="$(tput setaf 2)"
RED="$(tput bold; tput setaf 1)"
YELLOW="$(tput bold ; tput setaf 3)"
NC="$(tput sgr0)" # No Color


wprintf() {
    fmt=$1
    shift
    printf "%s${fmt}%s\n" "${WHITE}" "$@" "${NC}"

    return "${SUCCESS}"
}

# print warning
warn()
{
    printf "%s[!] WARNING: %s%s\n" "${RED}" "${*}" "${NC}"

    return "${SUCCESS}"
}

# print error and exit
err()
{
    printf "%s[-] ERROR: %s%s\n" "${RED}" "${*}" "${NC}"

    return "${SUCCESS}"
}

# print error and exit
cri()
{
    printf "%s[-] CRITICAL: %s%s\n" "${RED}" "${*}" "${NC}"

    exit "${FAILURE}"
}


# usage and help
usage()
{
cat <<EOF
Usage: $0 <arg> | <misc>
OPTIONS:
    -i: install
MISC:
    -V: print version and exit
    -H: print help and exit
EOF
    return "${SUCCESS}"
}

# leet banner, very important
banner()
{
    printf "%s--==[ BlackArch Install %s ]==--%s\n" "${YELLOW}" "${VERSION}" "${NC}"

    return "${SUCCESS}"
}

check_env()
{
    if [ -f /var/lib/pacman/db.lck ]; then
        cri "Pacman locked - rm /var/lib/pacman/db.lck"
    fi
}

# check argument count
check_argc()
{
    return "${SUCCESS}"
}

# check if required arguments were selected
check_args()
{
    return "${SUCCESS}"
}


update_system()
{
    if [ "$(uname -m)" == "x86_64" ]; then
        wprintf "[+] Enabling multilib"
        printf "[multilib]\nInclude = /etc/pacman.d/mirrorlist\n" >> /etc/pacman.conf
    fi

    pacman -Syy

    #fix this
    #sed -i '/[multilib]/{ s/^#//; n; s/^#//; }' /etc/pacman.conf

    return "${SUCCESS}"
}

format_filesystem()
{
    # TODO: add swap

    printf "%s" "${WHITE}"


    # user input settings
    printf "[+] Type the device for install [/dev/sda]: "; read a

    if [ "${a}" == "" ]; then
        HD="/dev/sda"
    else
        HD=${a}
    fi

    # boot partition
    printf "\n[+] Select partition number for /boot partition [%s1]: " "${HD}"; read a;
    if [ "${a}" == "" ]; then
        boot_part="${HD}"
    else
        # parse user input errors
        boot_part=${a}
    fi

    printf "\n[+] Select partition size for /boot [100MB]: "; read a
    if [ "${a}" == "" ]; then
        boot_size="100MB"
    else
        boot_size=${a}
    fi

    # root partition
    printf "\n[+] Select partition number for / partition [%s2]: " "${HD}"; read a
    if [ "${a}" == "" ]; then
        root_part="${HD}"
    else
        # parse user input errors
        root_part=${a}
    fi

    printf "\n[+] Select partition size for / [10GB]: "; read a
    if [ "${a}" == "" ]; then
        root_size="10GB"
    else
        root_size=${a}
    fi

    # about to format
    printf "%s" "${RED}"
    printf "\n[!!] About to format partitions:\n"
    printf "\t---> /boot %s - Size: %s\n" "${boot_part}" "${boot_size}"
    printf "\t---> /     %s - Size: %s\n" "${root_part}" "${root_size}"
    printf "Are you sure? [y/N]: "; read a
    printf "%s" "${WHITE}"

    if [ "${a}" == "y" ]; then

        # check if Partition Table already set
        # parted "/dev/${HD}" print | grep -q "Partition Table"
        parted -s "${HD}" mklabel msdos

        parted -a optimal "${boot_part}" mkpart primary 0% "${boot_size}"

        # partition bootable
        parted "${boot_part}" set 1 boot on

        parted -a optimal "${root_part}" mkpart primary "${boot_size}" "${root_size}"

        mkfs.ext2 -L boot "${boot_part}1"
        mkfs.ext4 -L root "${root_part}2"

        printf "[+] Created boot partition: %s - ext2\n" "${boot_part}"
        printf "[+] Created root partition: %s - ext4\n" "${root_part}"
    else
        format_filesystem
        return "${SUCCESS}"
    fi

    printf "%s" "${NC}"

    return "${SUCCESS}"
}

mount_filesystem()
{
    #TODO: change boot device for user required
    #TODO: optonal file system

    mkdir -p "${ROOT}"
    mount -t ext4 "${HD}2" "${ROOT}"
    mkdir -p "${ROOT}/boot"
    mount -t ext2 "${HD}1" "${ROOT}/boot"

    return "${SUCCESS}"
}

install_base_packages()
{
    wprintf "  --> ArchLinux Base"
    pacstrap -c "${ROOT}" base

    return "${SUCCESS}"
}

install_chroot()
{
    mode=${1}
	chroot_file="chroot-install"

    cp "${chroot_file}" "${ROOT}/bin"

    mount -t proc proc "${ROOT}/proc"
    mount --rbind /dev "${ROOT}/dev"
    mount --rbind /sys "${ROOT}/sys"

    chroot "${ROOT}" "${chroot_file}" "${mode}" -d "${HD}"

    # cleaning up
    rm -rf "${ROOT}/bin/${chroot_file}"

    return "${SUCCESS}"
}

install()
{
    menu_opt=${1}

    wprintf "[+] Updating system..."
    update_system

    wprintf "[+] Partitioning ${HD}..."
    format_filesystem

    wprintf "[+] Mounting filesystem..."
    mount_filesystem

    wprintf "[+] Installing packages..."
    install_base_packages

    wprintf "[+] Generating fstab..."
    genfstab -p "${ROOT}" >> "${ROOT}/etc/fstab"

    wprintf "[+] Generating pacman.conf"
    cp -Rf /etc/pacman* "${ROOT}/etc/"

    wprintf "[+] Generating resolv.conf"
    cp /etc/resolv.conf "${ROOT}/etc/"

    wprintf "[+] Setting up grub config..."
    cp grub/splash.png "${ROOT}/boot/"

    wprintf "[+] Installing chroot system..."

    case "${menu_opt}" in
        "1")
            err "Not Implemented Yet"
            ;;
        "2")
            install_chroot "-r"
            ;;
        "3")
            install_chroot "-b"
            ;;
    esac

    return "${SUCCESS}"
}

# parse command line options
get_opts()
{
    while getopts ivVH flags
    do
        case "${flags}" in
            i)
                #optarg=${OPTARG}
                opt="install"
                ;;
            v)
                VERBOSE="/dev/stdout"
                ;;
            V)
                printf "%s\n" "${VERSION}"
                exit "${SUCCESS}"
                ;;
            H)
                usage
                ;;
            *)
                err "WTF?! mount /dev/brain"
                ;;
        esac
    done

    return "${SUCCESS}"
}

install_menu()
{
    printf "%s" "${WHITE}"
    while ! [ "${menu_opt}" == "1" -o "${menu_opt}" == "2" -o "${menu_opt}" == "3" ]; do
        printf "[+] Select Install Mode:\n"
        printf "    1. Install from LiveCD.\n"
        printf "    2. Install from BlackArch Official Repository.\n"
        printf "    3. Install from Blackman.\n"
        printf "Make a choice: "; read menu_opt
        printf "%s"
    done

    printf "%s" "${NC}"

    return "${SUCCESS}"
}

# controller and program flow
main()
{
    banner
    check_argc ${*}
    get_opts ${*}
    check_args ${*}
    check_env

    # commented arg opt
    #if [ "${opt}" == "install" ]; then
        if [[ "${SEC_ENABLE}" == "false" ]]; then
            install_menu
            install "${menu_opt}"
        else
            cri "SEC_ENABLE var active - vim blackarch-install"
        fi
    #fi
    return "${SUCCESS}"
}


# program start
main ${*}

# EOF
